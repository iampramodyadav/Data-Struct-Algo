<h1>Table of Contents<span class="tocSkip"></span></h1>
<div class="toc"><ul class="toc-item"><li><span><a href="#Practice-Questions" data-toc-modified-id="Practice-Questions-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Practice Questions</a></span></li><li><span><a href="#Function" data-toc-modified-id="Function-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Function</a></span><ul class="toc-item"><li><span><a href="#Multiplication-Table" data-toc-modified-id="Multiplication-Table-2.1"><span class="toc-item-num">2.1&nbsp;&nbsp;</span>Multiplication Table</a></span></li><li><span><a href="#Twin-Prime" data-toc-modified-id="Twin-Prime-2.2"><span class="toc-item-num">2.2&nbsp;&nbsp;</span>Twin Prime</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.2.1"><span class="toc-item-num">2.2.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.2.2"><span class="toc-item-num">2.2.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li></ul></li><li><span><a href="#Prime-factorisation" data-toc-modified-id="Prime-factorisation-2.3"><span class="toc-item-num">2.3&nbsp;&nbsp;</span>Prime factorisation</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.3.1"><span class="toc-item-num">2.3.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2-More-efficient" data-toc-modified-id="Algorithm-2-More-efficient-2.3.2"><span class="toc-item-num">2.3.2&nbsp;&nbsp;</span>Algorithm-2 More efficient</a></span></li></ul></li><li><span><a href="#permutation-and-combination" data-toc-modified-id="permutation-and-combination-2.4"><span class="toc-item-num">2.4&nbsp;&nbsp;</span>permutation and combination</a></span></li><li><span><a href="#Decimal-to-binary" data-toc-modified-id="Decimal-to-binary-2.5"><span class="toc-item-num">2.5&nbsp;&nbsp;</span>Decimal to binary</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.5.1"><span class="toc-item-num">2.5.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2-(recursive-function)" data-toc-modified-id="Algorithm-2-(recursive-function)-2.5.2"><span class="toc-item-num">2.5.2&nbsp;&nbsp;</span>Algorithm-2 (recursive function)</a></span></li><li><span><a href="#Algorithm-3" data-toc-modified-id="Algorithm-3-2.5.3"><span class="toc-item-num">2.5.3&nbsp;&nbsp;</span>Algorithm-3</a></span></li></ul></li><li><span><a href="#Armstrong-number" data-toc-modified-id="Armstrong-number-2.6"><span class="toc-item-num">2.6&nbsp;&nbsp;</span>Armstrong number</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.6.1"><span class="toc-item-num">2.6.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.6.2"><span class="toc-item-num">2.6.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li></ul></li><li><span><a href="#Product-of-digit" data-toc-modified-id="Product-of-digit-2.7"><span class="toc-item-num">2.7&nbsp;&nbsp;</span>Product of digit</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.7.1"><span class="toc-item-num">2.7.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.7.2"><span class="toc-item-num">2.7.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li></ul></li><li><span><a href="#Multiplicative-digital-root" data-toc-modified-id="Multiplicative-digital-root-2.8"><span class="toc-item-num">2.8&nbsp;&nbsp;</span>Multiplicative digital root</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1-(Recursive-function)" data-toc-modified-id="Algorithm-1-(Recursive-function)-2.8.1"><span class="toc-item-num">2.8.1&nbsp;&nbsp;</span>Algorithm-1 (Recursive function)</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.8.2"><span class="toc-item-num">2.8.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li><li><span><a href="#Algorithm-2-(version-2)" data-toc-modified-id="Algorithm-2-(version-2)-2.8.3"><span class="toc-item-num">2.8.3&nbsp;&nbsp;</span>Algorithm-2 (version-2)</a></span></li></ul></li><li><span><a href="#HCF-of-two-number" data-toc-modified-id="HCF-of-two-number-2.9"><span class="toc-item-num">2.9&nbsp;&nbsp;</span>HCF of two number</a></span></li><li><span><a href="#Sum-of-proper-devisor" data-toc-modified-id="Sum-of-proper-devisor-2.10"><span class="toc-item-num">2.10&nbsp;&nbsp;</span>Sum of proper devisor</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.10.1"><span class="toc-item-num">2.10.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.10.2"><span class="toc-item-num">2.10.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li></ul></li><li><span><a href="#perfect-number" data-toc-modified-id="perfect-number-2.11"><span class="toc-item-num">2.11&nbsp;&nbsp;</span>perfect number</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.11.1"><span class="toc-item-num">2.11.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.11.2"><span class="toc-item-num">2.11.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li></ul></li><li><span><a href="#amicable-numbers" data-toc-modified-id="amicable-numbers-2.12"><span class="toc-item-num">2.12&nbsp;&nbsp;</span>amicable numbers</a></span><ul class="toc-item"><li><span><a href="#Algorithm-1" data-toc-modified-id="Algorithm-1-2.12.1"><span class="toc-item-num">2.12.1&nbsp;&nbsp;</span>Algorithm-1</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.12.2"><span class="toc-item-num">2.12.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li><li><span><a href="#Algorithm-2.2" data-toc-modified-id="Algorithm-2.2-2.12.3"><span class="toc-item-num">2.12.3&nbsp;&nbsp;</span>Algorithm-2.2</a></span></li></ul></li><li><span><a href="#odd-number-by-filter()" data-toc-modified-id="odd-number-by-filter()-2.13"><span class="toc-item-num">2.13&nbsp;&nbsp;</span>odd number by filter()</a></span><ul class="toc-item"><li><span><a href="#Agorithm-1" data-toc-modified-id="Agorithm-1-2.13.1"><span class="toc-item-num">2.13.1&nbsp;&nbsp;</span>Agorithm-1</a></span></li><li><span><a href="#Algorithm-2" data-toc-modified-id="Algorithm-2-2.13.2"><span class="toc-item-num">2.13.2&nbsp;&nbsp;</span>Algorithm-2</a></span></li></ul></li><li><span><a href="#map()" data-toc-modified-id="map()-2.14"><span class="toc-item-num">2.14&nbsp;&nbsp;</span>map()</a></span></li><li><span><a href="#map()-and-filter()" data-toc-modified-id="map()-and-filter()-2.15"><span class="toc-item-num">2.15&nbsp;&nbsp;</span>map() and filter()</a></span></li></ul></li></ul></div>

# Practice Questions

# Function

## Multiplication Table
- Write a function that inputs a number and prints the multiplication table of 
that number.



```python
def table(a):
    '''
  this function ptint table
  '''
    print("Table of {} is\n".format(a))
    for i in range(1, 11):
        print(
            i,
            "* ",
            a,
            "=",
            i * a,
        )
```


```python
table(10)
```

    Table of 10 is
    
    1 *  10 = 10
    2 *  10 = 20
    3 *  10 = 30
    4 *  10 = 40
    5 *  10 = 50
    6 *  10 = 60
    7 *  10 = 70
    8 *  10 = 80
    9 *  10 = 90
    10 *  10 = 100
    


```python
print(table.__doc__)
```

    
      this function ptint table
      
    

## Twin Prime
- Write a program to print twin primes less than 1000. If two consecutive odd numbers are both prime then they are known as twin primes. [twin prime](https://en.wikipedia.org/wiki/Twin_prime)

### Algorithm-1


---




```python
def isPrime(a):
    '''
  this function check for prime number and return true

  '''
    for i in range(2, int(a**0.5) + 1):
        if a % i == 0:
            return False
    return True


def TwinPrime(x):
    '''
  this function give twin prime numbers bellow entred number
  '''
    temp = 0
    for i in range(3, x, 2):
        if isPrime(i) and isPrime(i + 2):
            print("({},{})".format(i, i + 2))
            temp += 1
    print("no of twin prime is {}".format(temp))
```


```python
print(isPrime.__doc__)
```

    
      this function check for prime number and return true
    
      
    


```python
print(TwinPrime.__doc__)
```

    
      this function give twin prime numbers bellow entred number
      
    


```python
TwinPrime(1000)
```

    (3,5)
    (5,7)
    (11,13)
    (17,19)
    (29,31)
    (41,43)
    (59,61)
    (71,73)
    (101,103)
    (107,109)
    (137,139)
    (149,151)
    (179,181)
    (191,193)
    (197,199)
    (227,229)
    (239,241)
    (269,271)
    (281,283)
    (311,313)
    (347,349)
    (419,421)
    (431,433)
    (461,463)
    (521,523)
    (569,571)
    (599,601)
    (617,619)
    (641,643)
    (659,661)
    (809,811)
    (821,823)
    (827,829)
    (857,859)
    (881,883)
    no of twin prime is 35
    

### Algorithm-2

---




```python
def listPrime(a):
    """
  this function return list of prime number bellow enterd number
  """
    lst = []
    for i in range(2, a + 1):
        for j in range(2, int(i**0.5) + 1):
            if i % j == 0:
                break
        else:
            lst.append(i)
    return (lst)


def twinPrime2(x):
    """
  this function print twin prime from list of prime
  """
    temp = 0
    prime = listPrime(x)
    for i in range(len(prime) - 1):
        if prime[i + 1] - prime[i] == 2:
            print("({},{})".format(prime[i], prime[i + 1]))
            temp += 1
    print("Number of twin prime bellow {}, is {}".format(x, temp))
```


```python
print(listPrime.__doc__)
```

    
      this function return list of prime number bellow enterd number
      
    


```python
print(twinPrime2.__doc__)
```

    
      this function print twin prime from list of prime
      
    


```python
twinPrime2(1000)
```

    (3,5)
    (5,7)
    (11,13)
    (17,19)
    (29,31)
    (41,43)
    (59,61)
    (71,73)
    (101,103)
    (107,109)
    (137,139)
    (149,151)
    (179,181)
    (191,193)
    (197,199)
    (227,229)
    (239,241)
    (269,271)
    (281,283)
    (311,313)
    (347,349)
    (419,421)
    (431,433)
    (461,463)
    (521,523)
    (569,571)
    (599,601)
    (617,619)
    (641,643)
    (659,661)
    (809,811)
    (821,823)
    (827,829)
    (857,859)
    (881,883)
    Number of twin prime bellow 1000, is 35
    

## Prime factorization
Write a program to find out the prime factors of a number. Example: prime factors of 56 -2, 2, 2, 7


### Algorithm-1

---




```python
def primeFact(n):
  '''
  this function print list of prime factors for entered numbers
  '''
  if n==1:
    print('no prime factor for 1')
    return
  lst=[]

  for i in range(2,n):
    while n%i==0:
      lst.append(i)
      n=n//i

  print('prime factor of are: {}'.format(lst))

primeFact(44289)
```

    prime factor of are: [3, 3, 7, 19, 37]
    

### Algorithm-2 More efficient


```python
import math
def factors(num):
  """takes a number and prints prime factors of that number"""

  if num==1:
    print("no prime factors for 1")
    return

  factor=[]
  for i in range(2,int(math.sqrt(num))+1):    #we reduce the number of loop
    while num%i==0:
      factor.append(i)
      num=num//i

  if num!=1:                              #if there are any foctor >sqrt(num) then it will currecnlt in num
    factor.append(num)
  print("factors are: {}".format(factor))

factors(44289)
```

    factors are: [3, 3, 7, 19, 37]
    


```python
factors(9905973)
```

    factors are: [3, 7, 11, 19, 37, 61]
    


```python
primeFact(9905973)
```

    prime factor of are: [3, 7, 11, 19, 37, 61]
    


```python
primeFact(1263761079)
```

    prime factor of are: [3, 7, 17, 19, 211, 883]
    

it took 103 sec for abov number


```python
factors(1263761079)
```

    factors are: [3, 7, 17, 19, 211, 883]
    

it took 1.4 sec, so factor(n) is more efficient.

## permutation and combination
Write a program to implement these formula of permutations and combinations.
Number of permutations of n objects taken r at a time: p(n, r) = n! / (n-r)!. Number of combinations of n objects taken r at a time is: c(n, r) = n! / (r!*(n-r)!) = p(n,r) / r!


```python
def fact(n):
  '''
  return factorial of entered number
  '''
  n=int(n)
  factorial=1
  for i in range(1,n+1):
    factorial*=i
  return factorial

def p(n,r):
  '''
  return permutation of entered number
  '''
  if n<r:
    print("inavlid entry")
  perm=fact(n)/fact(n-r)
  return perm

def c(n,r):
  '''
  return combination of entered number
  '''
  if n<r:
    print('invalid')
  
  combi= p(n,r)/fact(r)
  return combi

n=int(input('enter the value of n :'))   #In python 3, the input() function returns a string.
r=int(input('entet the value of r :'))
print('permutation of entered numbers is {}, and combination is {}'.format(p(n,r),c(n,r)))
```

    enter the value of n :5
    entet the value of r :2
    permutation of entered numbers is 20.0, and combination is 10.0
    


```python
fact(5)
```




    120




```python
p(5,3)
```




    60.0




```python
c(5,3)
```




    10.0



## Decimal to binary
Write a function that converts a decimal number to binary number


### Algorithm-1


```python
def Decimal2Binary(num):
  """take a decimal number and return it's binary representaion"""
  lst=[]
  while num>0:
    i=num%2
    lst.insert(0,i) #or lst.append(i) then lst.reverse()
    num=num//2
  for i in lst:
    print(i, end='')
```


```python
l=Decimal2Binary(10)
```

    1010

### Algorithm-2 (recursive function)


```python
def rDecimal2Binary(num):
  """take a decimal number and return it's binary representaion"""
  
  if num>1:
    rDecimal2Binary(num//2)
  i=num%2
  print(i,end='')
```


```python
rDecimal2Binary(10)
```

    1010

### Algorithm-3


```python
def binary(num):
  """take a decimal number and return it's binary representaion"""
  temp=[]
  while num>0:
    temp.append(num & 1)    #bitwise operator &
    num=num>>1              #bitwise operator >>
  
  temp=temp[::-1]           #reversing the list
  temp=map(str,temp)
  return int("".join(temp))  #join and print
binary(10)
```




    1010




```python
24 & 1
```




    0




```python
24>>1
```




    12





## Armstrong number
 Write a function **cubesum()** that accepts an integer and returns the sum of the cubes of individual digits of that number. Use this function to make functions **PrintArmstrong()** and **isArmstrong()** to print Armstrong numbers and to find whether is an Armstrong number

### Algorithm-1

---




```python
def cubesum(n):
  '''this return sum of cube of its digit'''
  l=str(n)
  s=0
  for i in l:
    s=s+int(i)**3
  return s

def isArmstrong(a):
  '''check for armstrong number '''
  if a==cubesum(a):
    return True
  else:
    return False

def PrintArmstrong(num):
  '''print armstrong number '''
  if isArmstrong(num):
    print("{} is an armstrong number".format(num))
  else:
    print("{} is NOT an armstrong number".format(num))
```


```python
cubesum(153)
```




    153




```python
isArmstrong(153)
```




    True




```python
PrintArmstrong(153)
```

    153 is an armstrong number
    

### Algorithm-2

---




```python
def cubesum1(n):
  '''this return sum of cube of its digit'''
  s=0
  while n>0:
    i=n%10
    s=s+i**3
    n=n//10
  return s

def isArmstrong1(a):
  '''check for armstrong number '''
  if a==cubesum1(a):
    return True
  else:
    return False

def PrintArmstrong1(num):
  '''print armstrong number '''
  if isArmstrong1(num):
    print("{} is an armstrong number".format(num))
  else:
    print("{} is NOT an armstrong number".format(num))
```


```python
PrintArmstrong1(153)
```

    153 is an armstrong number
    


```python
PrintArmstrong1(370)
```

    370 is an armstrong number
    


```python
PrintArmstrong1(407)
```

    407 is an armstrong number
    

## Product of digit
Write a function prodDigits() that inputs a number and returns the product of digits of that number.

### Algorithm-1


```python
def prodDigit(n):
  '''this return product of its digit'''
  s=1
  while n>0:
    i=n%10
    s=s*i
    n=n//10
  return s
```


```python
prodDigit(1234546855)
```




    576000




```python
2%10
```




    2



### Algorithm-2


```python
def prodDigit_v2(n):
  '''this return product of its digit'''
  l=str(n)
  s=1
  for i in l:
    s=s*int(i)
  return s
```


```python
prodDigit_v2(1234546855)
```




    576000



## Multiplicative digital root
If all digits of a number n are multiplied by each other repeating with the product, the one digit number obtained at last is called the multiplicative digital root of n. The number of times digits need to be multiplied to reach one digit is called the multiplicative persistance of n.
Example:
```
86 -> 48 -> 32 -> 6 (MDR 6, MPersistence 3)
341 -> 12->2 (MDR 2, MPersistence 2)
```
Using the function prodDigits() of previous exercise write functions MDR() and MPersistence() that input a number and return its multiplicative digital root and multiplicative persistence respectively

### Algorithm-1 (Recursive function)


```python
def MDR(num):
  if num<10:
    return num
  else:
    num=prodDigit(num)
    return MDR(num)

def MPersistance(num):
  i=0
  while num>9:
    num=prodDigit(num)
    i+=1
  return i

```


```python
MDR(341)
```




    2




```python
MPersistance(341)
```




    2



### Algorithm-2 


```python
def MDR1(num):
  while num>9:
    num=prodDigit(num) 
  return num


def MPersistance1(num):
  i=0
  while num>9:
    num=prodDigit(num)
    i+=1
  return i
```


```python
MDR1(341)
```




    2




```python
MPersistance1(86)
```




    3



### Algorithm-2 (version-2)
(more efficient as looping decreased)


```python
def MDR3(num):
  num=prodDigit(num)
  while num>9:
    num=prodDigit(num) 
  return num


def MPersistance3(num):
  i=0
  while num>9:
    num=prodDigit(num)
    i+=1
  return i
```


```python
MDR(341)
```




    2



## HCF of two number
*  Write recursive function for HCF 




```python
def rHCF(a,b):
  """
  this function print HCF via recursion method
  """
  s=a if a<b else b
  l=b if a<b else a
  if l%s==0:
    return(s)
  else:
    a=l%s
    b=s
    return(rHCF(a,b))
```


```python
rHCF(121,33)
```




    11




```python
a=25;b=1215
print("the HCF of", a, "and", b ,"is", rHCF(a,b))
```

    the HCF of 25 and 1215 is 5
    


```python
print(rHCF.__doc__)
```

    
      this function print HCF via recursion method
      
    

## Sum of proper devisor
Write a function sumPdivisors() that finds the sum of proper divisors of a number. Proper
divisors of a number are those numbers by which the number is divisible, except the
number itself. For example proper divisors of 36 are 1, 2, 3, 4, 6, 9, 18

### Algorithm-1


```python
from functools import reduce

def sum1(a,b):
  return (a+b)

def sumPdivisor(n):
  lst=[]
  for i in range(1,n):
    if n%(i)==0:
      lst.append(i)
  print("proper divisors of {} is: {} \ntheir sum are".format(n,lst),end=': ')
  s=reduce(sum1,lst)
  return s


```


```python
sumPdivisor(36)
```

    proper divisors of 36 is: [1, 2, 3, 4, 6, 9, 12, 18] 
    their sum are: 




    55




```python
sumPdivisor(28)
```

    proper divisors of 28 is: [1, 2, 4, 7, 14] 
    their sum are: 




    28




```python
sum1(5,6)
```




    11



### Algorithm-2


```python
from functools import reduce
def sum1(a,b):
  return (a+b)

def sumPdivisor1(n):
  lst=[]
  for i in range(1,int(n**0.5)+1):
    if n%(i)==0:
      lst.append(i)
      d=n//i
      if d!=i and d!=n:
        lst.append(d)
  lst.sort()
  print("proper divisors of {} is: {} \ntheir sum are".format(n,lst),end=': ')
  return sum(lst)
```


```python
sumPdivisor1(36)
```

    proper divisors of 36 is: [1, 2, 3, 4, 6, 9, 12, 18] 
    their sum are: 




    55



## perfect number
* A number is called perfect if the sum of proper divisors of that number is equal to the number. For example 28 is perfect number, since 1+2+4+7+14=28. Write a program to
print all the perfect numbers in a given range

### Algorithm-1


```python
from functools import reduce
def sum1(a,b):
  return (a+b)

def sumPdivisor(n):
  lst=[]
  for i in range(1,n):
    if n%(i)==0:
      lst.append(i)
  s=reduce(sum1,lst)
  return s

def findPerfectNum(a,b):
  plst=[]
  for i in range(a+1,b):
    if sumPdivisor(i)==i:
      plst.append(i)
  return plst
```


```python
findPerfectNum(1,10000)
```




    [6, 28, 496, 8128]




```python
%%timeit
findPerfectNum(1,10000)
```

    1 loop, best of 5: 4.07 s per loop
    

### Algorithm-2


```python
def sumPdivisor1(n):
  lst=[]
  for i in range(1,int(n**0.5)+1):
    if n%(i)==0:
      lst.append(i)
      d=n//i
      if d!=i and d!=n:
        lst.append(d)
  #lst.sort()
  #print("proper divisors of {} is: {} \ntheir sum are".format(n,lst),end=': ')
  return sum(lst)

def findPerfectNum1(a,b):
  plst=[]
  for i in range(a+1,b):
    if sumPdivisor1(i)==i:
      plst.append(i)
  return plst
```


```python
findPerfectNum1(1,10000)
```




    [6, 28, 496, 8128]




```python
%%timeit
findPerfectNum1(1,10000)
```

    10 loops, best of 5: 61 ms per loop
    

## amicable numbers
* Two different numbers are called amicable numbers if the sum of the proper divisors of each is equal to the other number. For example 220 and 284 are amicable numbers.
```
sum of proper divisors of  220 = 1+2+4+5+10+11+20+22+44+55+110 = 284
Sum of proper divisors of 284 = 1+2+4+71+142 = 220
```

Write a function to print pairs of amicable numbers in a range

### Algorithm-1


```python
def sumPdivisorE(n):
  lst=[]
  for i in range(1,int(n**0.5)+1):
    if n%(i)==0:
      lst.append(i)
      d=n//i
      if d!=i and d!=n:
        lst.append(d)
  return sum(lst)

def printAmicableNum(a,b):
  """prints the pairs of amicable numbers in a range"""
  for i in range(a,b):
    for j in range(b,i,-1):
      if sumPdivisor1(i)==j and sumPdivisor1(j)==i:
        print(i,j)


```


```python
printAmicableNum(1,10000)
```

    220 284
    1184 1210
    2620 2924
    5020 5564
    6232 6368
    

### Algorithm-2


```python
def sumPdivisorE(n):
    lst = []
    for i in range(1, int(n**0.5) + 1):
        if n % (i) == 0:
            lst.append(i)
            d = n // i
            if d != i and d != n:
                lst.append(d)
    return sum(lst)


def printAmicableNumE(a, b):
    """prints the pairs of amicable numbers in a range"""
    for i in range(a, b + 1):
        temp = sumPdivisorE(i)
        if i != temp and sumPdivisor1(temp) == i:
            print(i, temp)
```


```python
printAmicableNumE(1,10000)
```

    220 284
    284 220
    1184 1210
    1210 1184
    2620 2924
    2924 2620
    5020 5564
    5564 5020
    6232 6368
    6368 6232
    

### Algorithm-2.2


```python
def amicables(low, high):
    """prints the pairs of amicable numbers in a range"""
    s = set()
    for i in range(low, high + 1):
        temp = sumPdivisorE(i)
        if temp != i and sumPdivisorE(temp) == i:
            s.add((min(i, temp), max(i, temp)))
    for i in list(s):
        print("{} is an amicable pair".format(i))


amicables(10, 10000)
```

    (1184, 1210) is an amicable pair
    (220, 284) is an amicable pair
    (5020, 5564) is an amicable pair
    (6232, 6368) is an amicable pair
    (2620, 2924) is an amicable pair
    

## odd number by filter()
* Write a program which can filter odd numbers in a list by using filter function

### Agorithm-1


```python
def oddout(num):
    if num % 2 == 0:
        return num


lst = [2, 6, 9, 7, 3, 5, 1, 6, 8]
lst2 = list(filter(oddout, lst))
lst2
```




    [2, 6, 6, 8]



### Algorithm-2


```python
lst = [2, 2, 5, 8, 9, 7, 5, 6, 3]
lst2 = list(filter(lambda x: x % 2 == 0, lst))
lst2
```




    [2, 2, 8, 6]



## map()

* Write a program which can map() to make a list whose elements are cube of elements in
a given list


```python
lst = [2, 3, 7, 9, 2]
lst2 = list(map(lambda x: x**3, lst))
lst2
```




    [8, 27, 343, 729, 8]



## map() and filter()

Write a program which can map() and filter() to make a list whose elements are cube of
even number in a given list


```python
lst = [2, 8, 4, 3, 4, 12, 13, 14]
lst3 = list(map(lambda x: x**3, list(filter(lambda x: x % 2 == 0, lst))))
lst3
```




    [8, 512, 64, 64, 1728, 2744]




```python

```
